/*
    _____ _____ _____ __
   |   __|     |  |  |  |      The SOUL language
   |__   |  |  |  |  |  |__    Copyright (c) 2019 - ROLI Ltd.
   |_____|_____|_____|_____|

   The code in this file is provided under the terms of the ISC license:

   Permission to use, copy, modify, and/or distribute this software for any purpose
   with or without fee is hereby granted, provided that the above copyright notice and
   this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

/**
    This namespace contains various simple oscillators
*/
namespace soul::oscillators
{
    using PhaseType = float32;  // TODO: this should probably be a defaulted namespace parameterisation
    let minFreqHz = 0.0;
    let maxFreqHz = 22000.0;
    let initFreqHz = 1000.0;

    //==============================================================================
    /** A unipolar ramp (phasor) oscillator.
        This is a non-bandlimited oscillator that will cause aliasing!
    */
    namespace phasor
    {
        struct State
        {
            PhaseType phase; // range 0 - 1
            PhaseType phaseIncrement;
        }

        void reset (State& s)
        {
            s.phase = PhaseType();
        }

        void update (State& s, float64 samplePeriod, float64 freqHz)
        {
            s.phaseIncrement = PhaseType (samplePeriod * freqHz);
        }

        PhaseType process (State& s)
        {
            s.phase += s.phaseIncrement;

            while (s.phase >= PhaseType (1.0))
                s.phase -= PhaseType (1.0);

            return s.phase;
        }

        processor Processor (using SampleType, float initialFrequency)
        {
            output stream SampleType out;

            input event float frequencyIn [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];

            event frequencyIn (float v) { s.update (processor.period, v); }

            State s;

            void init()
            {
                s.update (processor.period, initialFrequency);
            }

            void run()
            {
                loop
                {
                    out << SampleType (s.process());
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** A simple sinewave oscillator.
    */
    processor Sine (using SampleType, float initialFrequency)
    {
        output stream SampleType out;

        input event float frequencyIn  [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];

        event frequencyIn (float v) { phaseIncrement = float (v * twoPi * processor.period); }

        var phaseIncrement = float (initialFrequency * twoPi * processor.period);

        void run()
        {
            float phase;

            loop
            {
                out << sin (phase);
                phase = addModulo2Pi (phase, phaseIncrement);
                advance();
            }
        }
    }

    //==============================================================================
    /** A semi band-limited oscillator with Sawtooth, Square and Triangle wave shapes
        using the PolyBLEP (Polynomial Band-Limited Step) technique.
        You may want to oversample this oscillator, in order to reduce aliasing
    */
    namespace poly_blep (using SampleType)
    {
        //==============================================================================
        /** PolyBLEP shaper functions */
        namespace shapers
        {
            PhaseType polyblep (PhaseType phase, PhaseType phaseIncrement)
            {
                if (phase < phaseIncrement)
                {
                    phase /= phaseIncrement;
                    return (phase + phase) - (phase * phase) - PhaseType (1);
                }

                if (phase > PhaseType (1) - phaseIncrement)
                {
                    phase = (phase - PhaseType (1)) / phaseIncrement;
                    return (phase * phase) + (phase + phase) + PhaseType (1);
                }

                return PhaseType (0);
            }

            PhaseType sawtooth (phasor::State& s)
            {
                return PhaseType (-1) + (PhaseType (2) * s.phase) - polyblep (s.phase, s.phaseIncrement);
            }

            PhaseType square (phasor::State& s)
            {
                return (s.phase < PhaseType (0.5) ? PhaseType (-1) : PhaseType (1))
                        - polyblep (s.phase, s.phaseIncrement)
                        + polyblep (fmod (s.phase + PhaseType (0.5), PhaseType (1)), s.phaseIncrement);
            }
        }

        namespace Shape
        {
            let Sawtooth = 0;
            let Triangle = 1;
            let Square   = 2;
        }

        //==============================================================================
        /** A semi band-limited oscillator using the PolyBLEP technique
        */
        processor Processor (int initialShape, float initialFrequency)
        {
            output stream SampleType out;

            input event
            {
                float shapeIn       [[ name: "Shape",     min: 0,         max: 2,         init: 0,    text: "Sawtooth|Triangle|Square"]];
                float frequencyIn   [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];
            }

            event shapeIn (float v)         { shape = wrap<3> (floor (v)); triAccumulator = 1.0f; s.reset(); }
            event frequencyIn  (float v)    { s.update (processor.period, v); }

            phasor::State s;

            wrap<3> shape = wrap<3> (initialShape);
            PhaseType triAccumulator = 1.0f;

            void init()
            {
                s.update (processor.period, initialFrequency);
            }

            void run()
            {
                float32 y = 0.0f;

                loop
                {
                    if (shape == Shape::Sawtooth)
                    {
                        y = shapers::sawtooth (s);
                    }
                    else if (shape == Shape::Triangle)
                    {
                        triAccumulator += 4.0f * s.phaseIncrement * shapers::square (s);
                        y = triAccumulator;
                    }
                    else if (shape == Shape::Square)
                    {
                        y = shapers::square (s);
                    }

                    s.process();

                    out << y;

                    advance();
                }
            }
        }
    }
}
