/*
    _____ _____ _____ __
   |   __|     |  |  |  |      The SOUL language
   |__   |  |  |  |  |  |__    Copyright (c) 2019 - ROLI Ltd.
   |_____|_____|_____|_____|

   The code in this file is provided under the terms of the ISC license:

   Permission to use, copy, modify, and/or distribute this software for any purpose
   with or without fee is hereby granted, provided that the above copyright notice and
   this permission notice appear in all copies.

   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD
   TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN
   NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL
   DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER
   IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
   CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

/**
    This namespace contains various simple oscillators
*/
namespace soul::oscillators (using SampleType = float32)
{
    using PhaseType = float32;  // TODO: this should probably be a defaulted namespace parameterisation
    let minFreqHz = 0.0;
    let maxFreqHz = 22000.0;
    let initFreqHz = 1000.0;

    //==============================================================================
    /** A unipolar ramp (phasor) oscillator.
        This is a non-bandlimited oscillator that will cause aliasing!
    */
    namespace phasor
    {
        struct State
        {
            PhaseType phase; // range 0 - 1
            PhaseType phaseIncrement;
        }

        void reset (State& s)
        {
            s.phase = PhaseType();
        }

        void update (State& s, float64 samplePeriod, float64 freqHz)
        {
            s.phaseIncrement = PhaseType (samplePeriod * freqHz);
        }

        PhaseType process (State& s)
        {
            s.phase += s.phaseIncrement;

            while (s.phase >= PhaseType (1.0))
                s.phase -= PhaseType (1.0);

            return s.phase;
        }

        processor Processor (float initialFrequency)
        {
            output stream SampleType out;

            input event float frequencyIn [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];

            event frequencyIn (float v) { s.update (processor.period, v); }

            State s;

            void init()
            {
                s.update (processor.period, initialFrequency);
            }

            void run()
            {
                loop
                {
                    out << SampleType (s.process());
                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** A simple sinewave oscillator.
    */
    processor Sine (float initialFrequency)
    {
        output stream SampleType out;

        input event float frequencyIn  [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];

        event frequencyIn (float v) { phaseIncrement = float (v * twoPi * processor.period); }

        var phaseIncrement = float (initialFrequency * twoPi * processor.period);

        void run()
        {
            float phase;

            loop
            {
                out << sin (phase);
                phase = addModulo2Pi (phase, phaseIncrement);
                advance();
            }
        }
    }

    //==============================================================================
    /** A semi band-limited oscillator with sawtooth, square and triangle wave shapes
        using the PolyBLEP (Polynomial Band-Limited Step) technique.
        You may want to oversample this oscillator, in order to reduce aliasing
    */
    namespace poly_blep
    {
        namespace shapers
        {
            PhaseType polyblep (PhaseType phase, PhaseType phaseIncrement)
            {
                if (phase < phaseIncrement)
                {
                    phase /= phaseIncrement;
                    return (phase + phase) - (phase * phase) - PhaseType (1);
                }

                if (phase > PhaseType (1) - phaseIncrement)
                {
                    phase = (phase - PhaseType (1)) / phaseIncrement;
                    return (phase * phase) + (phase + phase) + PhaseType (1);
                }

                return PhaseType (0);
            }

            PhaseType sawtooth (phasor::State& s)
            {
                return PhaseType (-1) + (PhaseType (2) * s.phase) - polyblep (s.phase, s.phaseIncrement);
            }

            PhaseType square (phasor::State& s)
            {
                return (s.phase < PhaseType (0.5) ? PhaseType (-1) : PhaseType (1))
                        - polyblep (s.phase, s.phaseIncrement)
                        + polyblep (fmod (s.phase + PhaseType (0.5), PhaseType (1)), s.phaseIncrement);
            }
        }

        namespace Shape
        {
            let sawtooth = 0;
            let triangle = 1;
            let square   = 2;
        }

        processor Processor (int initialShape, float initialFrequency)
        {
            output stream SampleType out;

            input event
            {
                float shapeIn       [[ name: "Shape",     min: 0,         max: 2,         init: 0,    text: "Sawtooth|Triangle|Square"]];
                float frequencyIn   [[ name: "Frequency", min: minFreqHz, max: maxFreqHz, init: initFreqHz ]];
            }

            event shapeIn (float v)        { shape = wrap<3> (floor (v)); }
            event frequencyIn (float v)    { s.update (processor.period, v); }

            phasor::State s;
            var shape = wrap<3> (initialShape);

            void init()
            {
                s.update (processor.period, initialFrequency);
            }

            void run()
            {
                PhaseType y = PhaseType (0);
                PhaseType triAccumulator = PhaseType (0);

                loop
                {
                    if (shape == Shape::sawtooth)
                    {
                        y = shapers::sawtooth (s);
                    }
                    else if (shape == Shape::triangle)
                    {
                        // leaky integrator
                        let coefficient = PhaseType (1.0 - (0.25 * s.phaseIncrement));
                        triAccumulator = s.phaseIncrement * shapers::square (s) + coefficient * triAccumulator;
                        y = triAccumulator * PhaseType (4);
                    }
                    else if (shape == Shape::square)
                    {
                        y = shapers::square (s);
                    }

                    s.process();

                    out << SampleType (y);

                    advance();
                }
            }
        }
    }

    //==============================================================================
    /** A quadrature sinusoidal oscillator producing sine and cosine outputs simultaneously
        https://vicanek.de/articles/QuadOsc.pdf
    */
    namespace quadrature
    {
        let updateInterval = 16; // limit coefficient updates to every 16 samples

        struct State
        {
            SampleType u, v;
        }

        struct Coeffs
        {
            SampleType k1, k2;
        }

        void reset (State& s)
        {
            s.u = SampleType (1);
            s.v = SampleType();
        }

        void update (Coeffs& c, float64 freqHz, float64 sampleRate)
        {
            let w = twoPi * (freqHz / sampleRate);
            c.k1 = SampleType (tan (0.5 * w));
            c.k2 = SampleType (2.0 * c.k1 / (1.0 + c.k1 * c.k1));
        }

        SampleType[2] process (State& s, Coeffs& c)
        {
            let tmp = s.u - c.k1 * s.v;
            s.v = s.v + c.k2 * tmp;
            s.u = tmp - c.k1 * s.v;
            return SampleType[2] (s.v, s.u);
        }

        processor Processor (float initialFrequency)
        {
            output stream SampleType sineOut;
            output stream SampleType cosineOut;

            input event float frequencyIn [[ name: "Frequency", min: -maxFreqHz, max: maxFreqHz, init: 0.0 ]]; // Default meta data allows negative frequencies

            event frequencyIn (float v) { frequency = v; recalc = true; }

            float frequency = initialFrequency;
            bool recalc = true;

            void run()
            {
                State s;
                Coeffs c;

                s.reset();

                loop
                {
                    if (recalc)
                    {
                        recalc = false;
                        c.update (frequency, processor.frequency);
                    }

                    loop (updateInterval)
                    {
                        let y = s.process (c);
                        sineOut << y[0];
                        cosineOut << y[1];
                        advance();
                    }
                }
            }
        }
    }

    //==============================================================================
    /** A tempo-syncable LFO with some common shapes and options for uni-polar or bi-polar output
    */
    namespace lfo
    {
        namespace shapers
        {
            SampleType rampUp           (PhaseType phase) { return (phase * 2.0f) - 1.0f; }
            SampleType rampUpUnipolar   (PhaseType phase) { return phase; }
            SampleType rampDown         (PhaseType phase) { return ((1.0f - phase) * 2.0f) - 1.0f; }
            SampleType rampDownUnipolar (PhaseType phase) { return (1.0f - phase); }
            SampleType triangle         (PhaseType phase) { return (2.0f * (1.0f - abs ((wrap (phase + 0.25f, 1.0f) * 2.0f) -1.0f))) - 1.0f; }
            SampleType triangleUnipolar (PhaseType phase) { return 1.0f - abs((phase * 2.0f) - 1.0f ); }
            SampleType square           (PhaseType phase) { return (float (phase > 0.5f) * 2.0f) - 1.0f; }
            SampleType squareUnipolar   (PhaseType phase) { return float (phase > 0.5f); }
            SampleType sine             (PhaseType phase) { return sin (phase * float32 (twoPi)); }
            SampleType sineUnipolar     (PhaseType phase) { return (sin (phase * float32 (twoPi)) + 1.0f) * 0.5f; }
        }

        namespace Shape
        {
            let triangle = 0;
            let square   = 1;
            let rampUp   = 2;
            let rampDown = 3;
            let sine     = 4;
            let SAH      = 5;
        }

        namespace Divs
        {
            let k64n  = 0;
            let k32n  = 1;
            let k16nt = 2;
            let k16n  = 3;
            let k16nd = 4;
            let k8nt  = 5;
            let k8n   = 6;
            let k8nd  = 7;
            let k4n   = 8;
            let k4nd  = 9;
            let k2n   = 10;
            let k1bar = 11;
            let k2bar = 12;
            let k4bar = 13;
            let k8bar = 14;
        }

        namespace DivScalars
        {
            let k64n  = 64.0   / 4.0; // 1 sixty fourth of a beat
            let k32n  = 32.0   / 4.0; // 1 thirty second of a beat
            let k16nt = 24.0   / 4.0; // 1 sixteenth note triplet
            let k16n  = 16.0   / 4.0; // 1 sixteenth note
            let k16nd = 12.0   / 4.0; // 1 dotted sixteenth note
            let k8nt  = 9.0    / 4.0; // 1 eighth note triplet
            let k8n   = 8.0    / 4.0; // 1 eighth note
            let k8nd  = 6.0    / 4.0; // 1 dotted eighth note
            let k4n   = 4.0    / 4.0; // 1 quater note / 1 beat @ 4/4
            let k4nd  = 3.0    / 4.0; // 1 dotted quater note @ 4/4
            let k2n   = 2.0    / 4.0; // 2 beats @ 4/4
            let k1bar = 1.0    / 4.0; // 1 bar @ 4/4
            let k2bar = 0.5    / 4.0; // 2 bars @ 4/4
            let k4bar = 0.25   / 4.0; // 4 bars @ 4/4
            let k8bar = 0.125  / 4.0; // 8 bars @ 4/4
        }

        namespace Polarity
        {
            let unipolar = 0;
            let bipolar  = 1;
        }

        namespace smoother
        {
            struct State
            {
                float currentValue;
                float targetValue;
                float increment;
                int steps;
            }

            void reset (State& state, float initialValue)
            {
                state.currentValue = initialValue;
                state.targetValue = initialValue;
                state.increment = 0.0f;
                state.steps = 0;
            }

            void setTarget (State& state, float targetValue, int steps)
            {
                state.targetValue = targetValue;
                state.increment = (state.targetValue - state.currentValue) / steps;
                state.steps = steps;
            }

            float tick (State& state)
            {
                if (state.steps == 0)
                    return state.currentValue;

                state.currentValue += state.increment;
                state.steps--;

                if (state.steps == 0)
                    state.currentValue = state.targetValue;

                return state.currentValue;
            }
        }

        processor Processor (int initialShape, int initialPolarity, float initialDepth, float initialFreq)
        {
            output stream SampleType out;
            input event soul::timeline::Position positionIn;
            input event soul::timeline::TransportState transportStateIn;
            input event soul::timeline::Tempo tempoIn;

            input event
            {
                float rateHzIn     [[ name: "Rate (Hz)",     min: 0.01,  max: 40.0,   init: 1.,   unit: "hz", step: 0.01 ]];
                float rateTempoIn  [[ name: "Rate (Tempo)",  min: 0,     max: 14,     init: 0,    text: "1/64|1/32|1/16T|1/16|1/16D|1/8T|1/8|1/8D|1/4|1/4D|1/2|1/1|2/1|4/1|8/1"]];
                float depthIn      [[ name: "Depth",         min: 0,     max: 100,    init: 100,  unit: "%",  step: 1 ]];
                float shapeIn      [[ name: "Shape",         min: 0,     max: 5,      init: 0,    text: "Triangle|Square|Ramp Up|Ramp Down|Sine|Sample & Hold"]];
                float polarityIn   [[ name: "Polarity",      min: 0,     max: 1,      init: 0,    text: "Unipolar|Bipolar"]];
                float rateModeIn   [[ name: "Rate Mode",     min: 0,     max: 1,      init: 0,    text: "Hz|Tempo"]];
                float syncIn       [[ name: "Timeline Sync", min: 0,     max: 1,      init: 0,    text: "Off|On"]];
            }

            event positionIn (soul::timeline::Position v)             { qnPos = v.currentQuarterNote; }
            event transportStateIn (soul::timeline::TransportState v) { transportRunning = v.state > 0; }
            event tempoIn (soul::timeline::Tempo v)                   { qnPhaseIncrement = (v.bpm / 60.0f) * float (processor.period); }

            event rateHzIn (float v)
            {
                if (!qnMode)
                    phaseIncrement = PhaseType (v * processor.period);
            }

            event rateTempoIn (float v)
            {
                let div = int(floor(v));

                if      (div == Divs::k64n)  qnScalar = DivScalars::k64n;
                else if (div == Divs::k32n)  qnScalar = DivScalars::k32n;
                else if (div == Divs::k16nt) qnScalar = DivScalars::k16nt;
                else if (div == Divs::k16n)  qnScalar = DivScalars::k16n;
                else if (div == Divs::k16nd) qnScalar = DivScalars::k16nd;
                else if (div == Divs::k8nt)  qnScalar = DivScalars::k8nt;
                else if (div == Divs::k8n )  qnScalar = DivScalars::k8n;
                else if (div == Divs::k8nd)  qnScalar = DivScalars::k8nd;
                else if (div == Divs::k4n )  qnScalar = DivScalars::k4n;
                else if (div == Divs::k4nd)  qnScalar = DivScalars::k4nd;
                else if (div == Divs::k2n )  qnScalar = DivScalars::k2n;
                else if (div == Divs::k1bar) qnScalar = DivScalars::k1bar;
                else if (div == Divs::k2bar) qnScalar = DivScalars::k2bar;
                else if (div == Divs::k4bar) qnScalar = DivScalars::k4bar;
                else if (div == Divs::k8bar) qnScalar = DivScalars::k8bar;
            }

            event depthIn (float v)       { depth.setTarget (v * 0.01f, smoothingSamples); }
            event shapeIn (float v)       { shape = int (floor (v)); }
            event polarityIn (float v)    { polarity = (v < 0.5f) ? Polarity::unipolar : Polarity::bipolar; }
            event rateModeIn (float v)    { qnMode = v > 0.5f; }
            event syncIn (float v)        { timelineSync = v > 0.5f; }

            PhaseType phase;
            var phaseIncrement = float32 (initialFreq * processor.period);
            int shape = initialShape;
            int polarity = initialPolarity;
            smoother::State depth;

            let smoothingSamples = int (processor.frequency * 0.02);
            bool transportRunning = false;
            bool qnMode = false;
            bool timelineSync = false;
            float64 qnScalar = 1.0;
            float64 qnPos = 0.0;
            float32 qnPhaseIncrement = (120.0f / 60.0f) * (1.0f / 44100.0f); // Default = 1qn @ 120bpm / 44.1 sr

            PhaseType prevPhase = 1.0f;
            soul::random::RandomNumberState rng;
            SampleType noiseSample;

            SampleType getNoiseSample()
            {
                if (phase < prevPhase)
                    noiseSample = SampleType (rng.getNextBipolar());

                prevPhase = phase;
                return noiseSample;
            }

            SampleType getNextSample()
            {
                if (polarity == Polarity::bipolar)
                {
                    if (shape == Shape::triangle)  return shapers::triangle (phase);
                    if (shape == Shape::square)    return shapers::square (phase);
                    if (shape == Shape::rampUp)    return shapers::rampUp (phase);
                    if (shape == Shape::rampDown)  return shapers::rampDown (phase);
                    if (shape == Shape::sine)      return shapers::sine (phase);
                    if (shape == Shape::SAH)       return getNoiseSample();
                }
                else
                {
                    if (shape == Shape::triangle)  return shapers::triangleUnipolar (phase);
                    if (shape == Shape::square)    return shapers::squareUnipolar (phase);
                    if (shape == Shape::rampUp)    return shapers::rampUpUnipolar (phase);
                    if (shape == Shape::rampDown)  return shapers::rampDownUnipolar (phase);
                    if (shape == Shape::sine)      return shapers::sineUnipolar (phase);
                    if (shape == Shape::SAH)       return getNoiseSample();
                }

                return 0.0f;
            }

            void init()
            {
                depth.reset (initialDepth * 0.01f);
            }

            void run()
            {
                rng.reset (processor.id + 10);

                loop
                {
                    out << getNextSample() * depth.tick();

                    if (qnMode)
                    {
                        if (timelineSync && transportRunning)
                        {
                            let oneOverQNScalar = 1.0 / qnScalar;
                            qnPos += qnPhaseIncrement;
                            phase = float32 (fmod (qnPos, oneOverQNScalar) / oneOverQNScalar);
                        }
                        else // freewheel
                        {
                            phase += (qnPhaseIncrement * float32 (qnScalar));

                            while (phase >= 1.0f)
                                phase -= 1.0f;
                        }
                    }
                    else
                    {
                        phase += phaseIncrement;

                        while (phase >= 1.0f)
                            phase -= 1.0f;
                    }

                    advance();
                }
            }
        }
    }
}
